# 软件工程

## 为什么进行软件工程

### 什么是软件工程

#### 解决问题

面对一个庞大的，处理起来棘手的问题，我们必须通过分析对其进行调查，将问题分解成我们能理解并能处理的问题片。

我们能够将这个大问题用小问题集和它们之间的关系来描述

> 在解决问题中，子问题和它们之间的关系同等重要

![](image/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%9B%BE1.1%20%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B.png)

分析问题后，我们必须从表述问题各方面的部件来构建解决方案。图1.2表现了这个相反的过程：**综合**(Synthesis)

![](image/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%9B%BE1.2%20%E7%BB%BC%E5%90%88%E8%BF%87%E7%A8%8B.png)

将单个子问题的解决方案合成为原问题的解决方案是困难的

任何解决问题的技巧必须有两部分：

1. 分析问题，弄清本质
2. 基于分析综合/合成出一个解决方案

为了解决问题，我们使用各种方法(method)、工具(tool)、程序(procedure)及范例(paradigm)

方法：用于产生某种结果的正式的程序

工具：一件能以更好的方式完成某件事情的设备或自动化系统

程序：就像一个秘诀，是一致地产生特别产品的工具和方法的组合

范例：提供一个特别的构建软件的方案或哲学

> 如面向对象开发或面向过程开发这样的范例



软件工程师使用工具、方法、程序、范例来增强他们软件产品的质量，目标是使用有效的富有成果的途径来产生有效的问题解决方案



#### 软件工程师的位置

软件工程师通常更关注于计算机和程序语言本身，或者我们视他们为用于涉及、实现一个问题解决方案的工具

一名软件工程师集中于把计算机作为一个解决问题的工具，而不是调查硬件的设计或证明有关算法如何工作的理论

![](image/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%9B%BE1.3%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%92%8C%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png)



### 我们已经取得的成功

要产生健壮的、易于理解和维护、其工作起来尽可能最有效率和效果的代码，是需要有专业软件工程师的技能和理解力的。软件工程将设计和开发高质量的软件

软件使我们能比以前任何时候更快更有效的执行任务，如电子表格软件、电子邮件等等的普及

然而软件自身存在问题，通常系统的运行不是严密地按照我们所期望的那样

一个工程中的错误与一个大的软件系统中的错误二者间是有很大差别的，

故障(fault)、故障(error)和失败(failure)间的关系

故障：因人误解产生一个故障

错误：故障在执行某个软件活动时产生，称之为一个错误

失败：一个对系统要求行为的偏离，在系统交付之前或之后被发现

> 从开发者的角度来看，故障是系统内部视图，失败是外部视图：即用户能看到的问题
>
> 并非每一个故障对应一个失败

![](image/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%9B%BE1.4%20%E4%BA%BA%E4%B8%BA%E9%94%99%E8%AF%AF%E6%80%8E%E6%A0%B7%E5%BC%95%E8%B5%B7%E5%A4%B1%E8%B4%A5.png)

### 什么是好的软件

软件工程师必须找到确保产品具有合意的质量和效用的方法。因此，好的软件工程必须总是包括生产质量软件的策略。但在我们想出一个策略前，必须理解质量软件意味着什么。

可以从五个不同方面描述质量:

1. 先验视角 质量是人们能意识到而不能被定义的东西
2. 用户视角 质量是对目标的适切性
3. 制造业视角 质量就是规格的一致
4. 产品视角 质量依赖于固有产品特性
5. 价值视角 质量依赖于消费者为之付款的量

我们必须至少以三种方式考虑质量：产品质量 ，导致产品的过程的质量，处于它将适用的商业环境上下文中的产品的质量。  

**产品质量**

![](image/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/1.5%20McCall%E7%9A%84%E8%B4%A8%E9%87%8F%E6%A8%A1%E5%9E%8B.png)

我们经常建立将用户外部视角和开发者的内部视角关联起来的模型  

显示了外部质量因素（左侧）是怎样与产品质量标准（右侧）相关的  



**过程质量**

有许多活动影响最终产品质量；如果任何一些活动走偏，产品质量将受到损害。

开发和维护过程的质量跟产品质量同等重要

为过程建模的优点之一是我们能检查它并想方法改进它



**商业环境上下文中的质量**



### 谁实施软件工程

通常，一个项目的参与者属于三类：顾客，用户，或开发者。顾客就是为软件系统开发支付资金的公司、组织或个人。开发者就是为顾客开发软件系统的公司、组织或个人。这类人包括任何协调、指导程序员和测试人员所需要的管理人员。用户就实际使用这个系统的人员：坐在终端前或提交数据或读输出。  

![](image/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/1.7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E5%8F%82%E4%B8%8E%E8%80%85.png)

在最近几年，顾客、用户和开发者间简单的区别已经变得更加复杂。顾客和用户已经以各种方式涉入开发过程中。  



#### 系统元素

通过为系统各部分命名然后确定组成部分和另外组成部分如何关联来描述它  

识别是分析摆在我们面前的问题的第一步。  

**活动与对象**

一个活动（Activity）就是发生于系统中的某事  

活动中涉及的元素被称为对象（ object）或实体（ entity）  

**关系和系统边界  **

一旦实体和活动确定下来，我们将实体和它们的活动匹配。实体和活动间的关系是被清晰而仔细定义。  

一个实体定义包括实体来源的描述。一些项在已存在的文件中；另外的在活动期间建立  

实体的目的地也是重要的。一些项仅由一项活动使用，但另一些被预定地输入别的系统  

我们可在将**系统**（System）定义为如下事物的**集合**(collection)：一个实体集、一个活动集、一个实体与活动的联系的描述，和一个系统边界的定义。  



### 一个系统的方法

**相关系统**

很少有系统是独立于其他系统的，边界的概念是重要的

一旦系统边界得到描述，我们就很容易明白什么在里面什么不在里面、什么穿越了边界。 

一个系统存在于另一个系统内部也是可能的



## 过程建模与生命周期

**过程**(process)：一个用来产生某种想要的产品所涉及的活动、约束和资源的步骤序列

任何的过程有如下的特征：

1. 过程规定了所有的主要处理活动
2. 过程使用资源，服从一套约束(如时间约束)，并产生中间和最终产品
3. 过程可能由许多子过程通过某种方式组成，过程可能被定义为一个过程层次，这样组织起来以便每个子过程都有它们子集的过程模型
4. 每个处理活动都有其入口和出口，以便我们知道活动何时开始或结束
5. 活动以一定次序组织起来，以便一个活动相对其他活动应该何时开始清楚，每个过程由一套知道原则来解释每项活动的目标
6. 约束或控制可以应用到一项活动、资源或产品

**生命周期**(life cycle)：当过程涉及某种产品的建立时，我们称这个过程为

软件开发过程有时称为**软件生命周期**(software life cycle)，其描述了一件软件产品的生命

> 软件产品的生命从概念、实现、交付、使用到维护

过程往活动集上加入了一致性和结构，一个过程模型要求设计在编码前，但允许使用许多不同的技术设计



过程不仅仅是**程序**(procedure)，程序是一种组合工具和技术的生成产品的结构化方式，而过程是程序的收集，组合起来以便我们建立满足一套目标或标准的产品，过程可能建议我们从几个程序中挑选。



**过程结构**（process structure）通过让我们考察理解控制改进组成过程的活动来引导我们的行为。  



软件开发通常包括以下几个阶段：  

1. 需求分析与定义
2. 系统设计
3. 程序设计
4. 程序实现
5. 单元测试
6. 综合测试
7. 系统测试
8. 系统交付
9. 维护

每个阶段本身就是能描述为一个活动集合的过程（或过程收集）。每项活动涉汲约束，与交出和资源  



### 软件过程模型

#### 瀑布模型(Waterfall Model)

![](image/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/2.1%20%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B.png)

瀑布模型如瀑布一样，由一个阶段向另一个阶段落下

帮助开发者安排它们需要做什么

易于向不熟悉软件开发的顾客解释说明

使得为开始下一阶段需要哪些中间产品更为明确

许多更复杂的模型只是瀑布模型的一个修饰



不足：没有反映代码等实际的开发过程，

![](image/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/2.2%20%E5%AE%9E%E9%99%85%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91.png)

实际的软件开发可能像2.2一样，带有大量的重复

软件开发过程通过包括增强的理解和子过程来控制这种打击

"**原型**"(prototype)就是那样一个子过程，原型是一个局部地开发地产品，使顾客和开发者来考察目标系统地某些方面，决定它是否对完成地产品适合或恰当

> 比如：开发者建立一个系统的一些关键性需求的一小部分，以确信需求是一致的，灵活的、实际的，如果不，则在需求阶段就做出修改

类似的，设计部分也可以被原型化

![](image/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%8E%9F%E5%9E%8B%E5%8C%96%E7%9A%84%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B.png)

确认（validation）确保系统已实现了所有需求；验证（verification）确保每一功能正确地工作。也就是说，确认确保开发者正建立正确的产品（按照规格），而验证检查实现的质量。“原型法” 对确认和验证是有用的  



#### V模型 (VModel)

![](image/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/V%E6%A8%A1%E5%9E%8B.png)

V 模型是瀑布模型的变种，示范了如何将测试和分析设计关系起来  

编码为V的顶点,分析和设计在左,测试和维护在右。  



#### 原型模型 (prototyping Model)

我们已看到如何用原型活动来修改瀑布模型以增进理解。但原型法不需要只是瀑布模型的附属物；它自身就是一个有效的过程模型原基础  

![](image/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/2.5%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%9E%8B.png)

降低了开发时的风险和不确定性

> 第一步是快速建立一个能反映用户主要需求的原型系统，让用户在计算机上试用它，通过实践来了解目标系统的概貌。通常，用户试用原型系统之后会提出许多修改意见，开发人员按照用户的意见快速地修改原型系统，然后再次请用户试用。一旦用户认为这个原型系统确实能做他们所需要的工作，开发人员便可据此书写规格说明文档，根据这份文档开发出的软件便可以满足用户的真实需求。
>



#### 操作规格(Operational Specification)模型

对于许多系统，需求的不确定性导致了后续开发的变化和问题

Zave提出了一种过程模型，允许开发人员和顾客可以在早期开发过程中检查需求和他们的影响，以便他们可以讨论和解决一些不确定性

在**操作规格模型**中，系统需求以展示系统行为的方式进行评估或执行

一旦指定了需求，就可以使用软件包来实现，因此可以在设计开始之前评估它们的影响。

与传统的瀑布模型不同，操作规范允许将功能和设计合并

> 瀑布模型将系统的功能性和设计分离，也就是说系统做什么和系统怎么做是分离的
>
> 旨在将客户需求与实施分开

操作规范与原型设计类似；这一过程使用户和开发人员能够尽早审查需求。

![](image/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/2.6%20%E6%93%8D%E4%BD%9C%E8%A7%84%E8%8C%83%E6%A8%A1%E5%9E%8B.png)

#### 转化(Transformational)模型