# 密码编码学与网络安全

# 第一部分 概览

## 第1章 计算机与网络安全概念

本书主要讨论两大领域：

1. 广泛使用的密码算法与协议
2. 大量依赖于密码技术的网络和Internet安全

**密码算法与协议**又可以分为4个主要领域：

1. 对称加密：加密任意大小的数据块或数据流的内容(包括消息、文件、加密密钥和口令)
2. 非对称加密 加密小数据块(如加密密钥或数字签名中使用的散列函数值)
3. 数据完整性算法 保护数据块的内容不被修改
4. 认证协议 基于密码算法设计的认证方案，用来认证实体的身份

**网络和Internet安全**领域涉及组织、防止、检测和纠正信息传出中出现的安全违规行为的措施，其内容相当广泛



### 1.1计算机安全的概念

对于一个自动化的信息系统，采取保护措施确保信息系统资源(包括硬件，软件，固件，信息/数据和通信)的完整性、可用性和保密性

> 定义来自NIST的《计算机安全手册》

- 保密性(Confidentiality)
  - 数据保密性 确保隐私或秘密信息不向非授权者泄露，也不被非授权者使用
  - 隐私性 确保个人能够控制或确定与其自身相关的哪些信息是可以被收集、保存的，这些信息可以由谁来公开以及向谁公开
- 完整性(Integrity)
  - 数据完整性 确保信息和程序只能以特定和授权的方式进行改变
  - 系统完整性 确保系统以一种正常方式来执行预定的功能，免于有意或无意的非授权操作

- 可用性(Availability)

系统能工作迅速，对授权用户不能拒绝服务

这三个概念组成了CIA三元组，其体现了数据、信息和计算服务的基本安全目标



一些额外的安全概念：

- 真实性(Authenticity)

一个实体是真实性的，可被验证的和可被信任的特性

> 对于传输信息来说，信息和信息来源是正确的

- 可追溯性(Accountability)

这时安全目标要求实体行为可以唯一追溯到实体，这一属性支持不可否认性，组织，故障隔离，入侵预测和预防，时候恢复，以及法律诉讼



### 1.2 OSI安全架构

OSI安全架构是提供安全的一种组织方法，这个框架是作为国际标准而开发的

OSI安全架构主要关注安全攻击、安全机制和安全服务，它们简短地定义如下：

**安全攻击**

任何危机信息系统安全的行为

**安全机制**

用来检测、组织攻击或从攻击状态恢复到正常状态的过程(或实现该过程的设备)

**安全服务**

加强数据处理系统和信息传输的安全性的一种处理过程或通信服务，目的在于利用一种或多种安全机制进行反攻击



### 1.3 安全攻击

X.800和RFC4949都将攻击划分为被动攻击和主动攻击

#### 1.3.1 被动攻击

被动攻击的特性是对传输进行窃听和监测

攻击者的目标是获得传输的信息，信息内容的泄露和流量分析都属于被动攻击

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%9B%BE1.2%20%E5%AE%89%E5%85%A8%E6%94%BB%E5%87%BB.png)

信息内容的泄露很容易理解

**流量分析**

假设我们已经使用方法隐藏了消息内容或其他信息流量，攻击者即使截获了消息也无法从消息中获得信息

即使我们对消息进行了恰当的加密保护，攻击者仍能具有可能获得这些消息的一些模式。

> 攻击者可以确定通信主机的身份和位置，可以观察到传输消息的频率和长度，攻击者可以利用这些信息来判断通信的某些性质

#### 1.3.2 主动攻击

主动攻击包括对数据流进行修改或伪造数据流，分为四类：伪造、重放、消息修改和拒绝服务

**伪造**

某实体伪装成其他实体，伪装攻击通常还包含其他形式的主动攻击

> 例如：截获某认证信息，并在认证信息完成合法验证后进行重放，无权限的实体就可以通过冒充有权限的实体获得额外的权限

**重放**

攻击者未经授权地将解惑地信息再次发送

**消息修改**

未经授权地修改合法消息地一部分，或延迟消息地传送，改变消息的顺序

**拒绝服务**

组织或禁止对通信设施的正常使用或管理

> 拒绝服务的另一种形式是破坏整个网络，或是使网络失效，过载以降低其性能



主动攻击难以绝对预防，所以对于主动攻击，重点在于检测并从攻击造成的破坏或延迟中恢复过来



### 1.4 安全服务

**安全服务的定义**

在通信开放系统中，为系统或数据传输提供足够安全的协议层服务(X.800)

安全服务是一种由系统提供的对系统资源进行特殊保护的处理或通信服务，安全服务通过安全机制来实现安全策略(RFC4949)

**安全服务的分类**

X.800将这些服务分为5类共14个特定服务

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E8%A1%A81.2%20%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1.png)

#### 1.4.1 认证

认证服务用以保证通信的真实性

对于单条消息的情况，认证服务功能向接收方保证消息确实来自所声称的发送方

对于进行中的通信，会涉及发送方和接收方两个主体

在连接的初始化阶段，认证服务保证两个实体是可信的，也就是说，每个实体是他们所声称的实体。其次，认证服务必须保证该连接不受第三方干扰

> 第三方干扰是指，第三方伪装成两个合法实体中的一个进行非授权传输或接收

X.800定义了以下两个特殊的认证服务：

- **对等实体认证**

为连接中的对等实体提供身份确认

- **数据源认证**

为数据的来源提供确认，对数据的赋值和修改并不提供保护

#### 1.4.2 访问控制

在网络安全中，访问控制是限制和控制那些通过通信连接对主机与应用进行访问的一种能力

> 每个试图获得访问控制的实体必须被识别或认证后，才能获取相应的访问权限

#### 1.4.3 数据保密性

**防止传输的数据遭到被动攻击**

关于数据传输，其保护可以分成不同的层级，最广泛的服务是在一段时间内为两个用户间传输的所有用户数据提供保护

也可以定义一种较窄的保密性服务，可以是为单条消息或者对单挑消息内的某个特定的范围提供保护，与广泛的方法相比，这种细化用处要少，实现起来更复杂，成本更高



保密性的另一个方面是要**防止流量分析**

#### 1.4.4 数据完整性

数据完整性可应用于消息流、单条消息或消息的指定部分。最直接和最有用的方法是对整个数据流提供保护

用于处理消息流、而向连接的完整性服务保证收到的消息和发出的消息一致，保证消息未被复制、插入、修改、更改顺序或重放。该服务也涉及对数据的破坏。因此，**面向连接的完整性服务需要处理消息流的修改和拒绝服务两个问题**。另一方面，**无连接的完整性服务仅处理单条消息**，而不管大量的上下文信息，因此通常仅防止对消息的修改。

**完整性服务还可分为可恢复的服务和无恢复的服务**。因为完整性服务和主动攻击有关，我们更关心检测而非阻止攻击。如果检测到完整性遭破坏，那么服务可以简单地报告这种破坏，并通过软件的其他部分或人工干预来恢复被破坏的部分。也可使用一些机制来恢复数据完整性，通常，自动恢复机制是一种更有吸引力的选择。



#### 1.4.5 不可否认性

不可否认性防止发送方或接收方否认传输或接收过某条消息

#### 1.4.6 可用性服务

根据系统的性能说明，系统资源可被授权实体请求访问或使用



### 1.5 安全机制

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E8%A1%A81.3%20%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%20%E8%A1%A81.4%20%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1%E4%B8%8E%E6%9C%BA%E5%88%B6%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB.png)

由上表可知，安全机制分为两类：一类在特定的协议层实现，如TCP或应用层协议。另一类不属于任何协议层或安全服务

可逆加密机制是一种单纯的加密算法，数据可以加密和解密

不可逆加密机制包括用于数字签名和消息认证应用中的散列算法与消息认证码



### 1.6 网络安全模型

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%9B%BE1.5%20%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B.png)

需要保护传输信息，防止攻击者对信息机密性、真实性等进行攻击时，安全技术开始发挥作用

所有提供安全的技术都包含以下两部分：

- 对发送信息的安全变换 (如加密消息，基于消息内容，附加一段基于消息内容的编码，用于验证发送者身份)

- 被两个主体共享且不被攻击者知道的一些机密信息。如在传输之前用于加密信息，收到消息后用于解密消息的密钥

为了实现安全传输，可能需要有可信的第三方。例如，第三方负责将秘密信息分配给通信双方而对攻击者保密，或当通信双方关于信息传输的真实性发生争执时，由第三方来仲裁。

上述模型说明，设计安全服务应包含如下4个方面的内容:

1. 设计一个算法，它执行与安全相关的变换。该算法应是攻击者无法攻破的。
2. 产生算法所使用的秘密信息。
3. 设计分配和共享秘密信息的方法
4. 指明通信双方使用的协议，该协议利用安全算法和秘密信息实现安全服务。



另一种有害访问是在计算机系统中加入程序，利用系统的弱点来影响应用程序和实用功能程如编辑程序和编译程序。这种程序引起的威胁有两种程序:

1. **信息访问威胁** 以未授权用户的名义截获或修改数据
2. **服务威胁** 利用计算机中的服务缺陷禁止合法用户使用这些服务

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%9B%BE1.6%20%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B.png)

对付有害访问所需的安全机制分为两大类。

第一类称为门卫功能，它包括基于口令的登录过程(该过程只允许授权用户的访问)和监控程序(负责检测和阻止蠕虫、病毒及其他类似的攻击)。

一旦非法用户或软件获得了访问权，那么由各种内部控制程序组成的第二道防线就会监视其活动、分析存储的信息，以便检测非法入侵者。



## 第2章 数论基础

### 2.1 整除性和带余除法

#### 2.1.1 整除

**整除的定义**

设a,b,m均为整数，若存在某个m似的a=mb成立，则称非零数b整除a，记作
$$
b|a
$$
同时，称b为a的一个因子

**整除的相关性质**

1. 若a|1，则a=±1
2. 若a|b，且b|a，则a=±b
3. 任何不等于0的数整除0
4. 若a|b且b|c，则a|c
5. 对于任意整数m,n，若b|g且b|h，则可得出b|(mg+nh)

#### 2.1.2 带余除法

对给定的任意一个正整数n和任意非负整数a,若用n除a，得到整数商q和整数余数r,则满足下列关系式：
$$
a=qn+r，~~~0\le r<n;q=\lfloor a|n \rfloor
$$


### 2.2 欧几里得算法

欧几里得算法是数论中一个最基本的技巧，用于简单地求出两个正整数的最大公因子

两个整数是互素的$\iff$ 这两个整数只有一个正整数公因子1

#### 2.2.1 最大公因子

整数a和b的最大公因子是能同时整除a和b的最大整数，记作gcd(a,b)

更正式的描述是：

1. c是a和b的因子
2. a、b的公因子都是c的一个因子

另一个等效定义
$$
gcd(a,b)=max[k,满足k|a,k|b]
$$
要求最大公因子必须是正数，所以
$$
gcd(a,b)=gcd(|a|,|b|)
$$
特别的
$$
gcd(a,0)=|a|
$$
**互素（互质）**

我们说整数a，b互质，当且仅当它们只有一个正整数公因子1



#### 2.2.2 求最大公因子

欧几里得算法可以简单地求出两个整数的最大公因子，算法的阐述可分为以下几点：

1. 假设我们需要求出整数a和b的最大公因子d；因为gcd(|a|,|b|)=gcd(a,b)，因此这里可以假定$a\ge b>0$
2. 使用带余除法，b除a可以表示为

$$
a=q_1b+r_1~~~0\le r_1<b
$$

3. 首先考虑到$r_1=0$的情况，因此可知b整除a，且a和b的公因子中不存在比b更大的数。所以d=gcd(a,b)=b
4. $r_1\ne 0$ 在这种情况下，可知一定有d|$r_1$，因为由因子的基本性质可知：存在d|a和d|b，那么一定有d|(a-$q_1b$)，即$d|r_1$
5. d|b和$d|r_1$,则，对于任意一个b和$r_1$的公因子c，有c|$(q_1b+r_1)=a$，因为c|a,c|b，所以$c\le d$，其中d是a和b的最大公因子，因此d=gcd($b,r_1$)

![](image/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95.png)

### 2.3 模运算

#### 2.3.1 模

如果a是一个整数，n是正整数，则我们定义a除以n所得的余数为a模n。整数n称为模数。所以带余除法可以写作
$$
a=\lfloor a/n \rfloor +(a~mod~n)
$$

#### 2.3.2 同余的性质

1. 若$n|(a-b)$，则$a\equiv b (mod~n)$
2. 若$a\equiv b (mod~n)$,则$b\equiv a(mod~n)$
3. 若$a\equiv b (mod~n)$，$b\equiv c (mod~n)$，则有$a\equiv c (mod~n)$



#### 2.3.3 模算术运算

模运算mod n，将所有整数映射到集合{0,1,...,(n-1)}中，我们可以在这个集合上进行算术运算，称为模算术

模算术有如下性质:
$$
(1)~[(a~mod~n)+(b~mod~n)]=(a+b)~mod~n\\
(2)~[(a~mod~n)-(b~mod~n)]=(a-b)~mod~n\\
(3)~[(a~mod~n)\times (b~mod~n)]=(a\times b)~mod~n\\
$$


#### 2.3.4 模运算的性质

定义比n小的非负整数集合为$Z_n$
$$
Z_n={0,1,...,(n-1)}
$$
这个集合称为剩余类集，或模n剩余类，Zn中的每一个整数都代表一个剩余类，我们可以将模n的剩余类表示为[0],[1],...,[n-1]

其中
$$
[r]=\{a:a是一个整数，a\equiv r(mod~n)\}
$$
在剩余类的所有整数中，我们通常使用最小非负整数来代表这个剩余类。寻找与k是模n同于的最小非负整数的过程，称为模n的k约化

**$Z_n$是有乘法单位元的交换环** 满足以下性质

![](image/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Zn%E4%B8%AD%E6%95%B4%E6%95%B0%E6%A8%A1%E8%BF%90%E7%AE%97%E7%9A%84%E6%80%A7%E8%B4%A8.png)



若a与n互素，则
$$
(a\times b)\equiv (a\times c)(mod~n),则b\equiv c(mod~n)
$$
对于任何一般的模数n，若a与n有任何公因子的话，用乘数a依次作用于0到n-1的所有整数将不会产生a的一个完整剩余类集

只有一个整数与n互素时，它才会在Zn中存在一个乘法逆元

#### 2.3.5 回顾欧几里得算法

欧几里得算法可以写成如下形式，对任意整数a,b满足$a\ge b \ge 0$
$$
gcd(a,b)=gcd(b,a~mod~b)
$$


#### 2.3.6 扩展的欧几里得算法

扩展的欧几里得算法不仅可以计算出最大公因子d，而且可以得到两个整数x和y，满足
$$
ax+by=d=gcd(a,b)
$$
x,y一定具有相反的正负号

对于两个给定的整数a和b，可以表示为ax+by的最小正整数等于gcd(a,b)

下面介绍如何通过扩展欧几里得算法得到(x,y,d)
$$
a=q_1b+r_1,r_1=ax_1+by_1\\
b=q_1r_1+r_2,r_2=ax_2+by_2\\
...\\
r{n-2}=q_{n}r_{n-}+r_n,r_{n}=ax_n+by_n\\
r_{n-1}=q_{n+1}r_n+0
$$
由上式有
$$
r_i=r_{i-2}-q_ir_{i-1}\\
x_i=x_{i-2}-q_ix_{i-1}\\
y_i=y_{i-2}-q_iy_{i-1}\\
$$
其中$r_{-1}=a,r_0=b$



### 2.4 素数

**素数**

整数p>1是素数，当且仅当它只有因子±1和±p

**算术基本定理**

任意整数a>1都可以唯一地因式分解为
$$
a=p_1^{\alpha_1}\times p_2^{\alpha_2}\times...\times p_t^{\alpha_t}
$$
$p_1,...,p_t$均是素数，且$p_1<p_2<...<p_t$,且所有$a_i$都是正整数

**正整数的另一种表述**

设P是所有素数的集合，任意的正整数a可唯一表示为
$$
a=\prod_{p\in P}p^{\alpha_p},a_p\ge 0
$$
在这种情况下，两数相乘即对应指数相加

从素因子角度看整除，意味着任意整数n形成的$p^n$只能被小于等于相同次幂的同一素数$p^j$整除

若a整除b，则对于任意的$p\in P$ 有
$$
a_p\le b_p
$$
若将整数表示为素数之积，则很容易确定两个正整数的最大公因子
$$
若k=gcd(a,b)，则k_p=min(a_p,b_p),其中p\in P
$$

### 2.5 费马定理和欧拉定理

费马定理和欧拉定理在公钥密码学中占有重要地位

#### 2.5.1 费马定理

通常指费马小定理

若p是素数，a是正整数且不能被p整除，则
$$
a^{p-1}\equiv 1(mod~p)
$$
另一种形式,若p是素数且a是任意正整数,则
$$
a^p\equiv a~mod~p
$$

> 注意，这里不要求a与p互素，而第一个式子要求a与p互素

#### 2.5.2 欧拉函数

欧拉函数$\phi(n)$,指小于n且与n互素的正整数个数,$\phi(1)=1$

显然，对于素数 $\phi(p)=p-1$

假设有两个素数p和q，$p\ne q$，那么对于n=pq，有
$$
\phi(n)=\phi(pq)=\phi(p)\times \phi(q)=(p-1)(q-1)
$$


#### 2.5.3 欧拉定理

对于任意互素的a和n，有
$$
a^{\phi(n)}=1(mod~n)
$$

另一种形式
$$
a^{\phi(n)+1}=a(mod~n)
$$

> 与费马定理类似，后一种形式不要求a和n互素 



### 2.6 素性检验

许多密码算法都需要随机选择一个或多个非常大的素数，我们必须能够确定一个给定的大数是否是素数，这是一个困难问题

本节介绍一种较好的常用算法，该算法产生的数不一定是素数，但几乎可以肯定是素数

#### 2.6.1 Miller-Rabin算法

**预备知识**

$n\ge3$的奇整数可以表示如下
$$
n-1=2^kq,~~k>0,q是奇数
$$
素数的两个性质：

1. 若p是素数，a是小于p的正整数，则$a^2~mod~p=1$当且仅当$a~mod~p=1或a~mod~p=-1=p-1$
2. 设p是大于2的素数，我们有p-1=$2^kq$,其中k>0,q为奇数，设a是整数且1<a<p-1,则下面两个条件之一成立:
   1. $a^q~mod~p=1$
   2. 整数$a^q,a^{2q},a^{4q},...,a^{2^{k-1}q}$中存在一个数，模p时与-1同余



由此可得，若n为素数，则剩余类数列($a^q,a^{2q},...,a^{2^kq}$)中，要么第一个数模n为1，要么数列中某个数模n为(n-1)

> 另外，如果条件满足，无法确定n是否是素数

我们可以利用上述性质做素性测试

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Miller-Robin%E7%B4%A0%E6%80%A7%E6%A3%80%E9%AA%8C.png)

我们可以重复使用Miller-Rabin算法，如果选择t个不同的a，都能通过测试，那么在t足够大的情况下，我们能以很大把握说n是素数

> ASK算法是一个判定一个大数是否为素数的确定性算法，但执行速度较慢，未能代替古老的概率算法

#### 2.6.3 素数的分布

**素数定理**

n附近的素数分布情况为，平均每ln(n)个整数中有一个素数，因为所有的偶数一定不是素数，则我们找到一个素数钱，需要测试的整数个数为0.5xln(n)

> 上面所说的只是平均值，数轴上有些位置，素数非常密集，而有些位置，素数非常稀疏

### 2.7 中国剩余定理

某一范围内的整数可通过它的一组剩余类数来重构，这组剩余类数是对该整数使用一组两两互素的整数取模得到的

一种表示形式
$$
M=\prod_{i=1}^k m_i
$$
其中$m_i$是两两互素的，即对$1\le i,j\le k$有gcd$(m_i,m_j)=1$我们可以将$Z_M$中的任一整数对应一个k元组，该k元组的元组均在$Z_{m_i}$中，这种对应关系即为
$$
A\leftrightarrow (a_1,a_2,...,a_k)
$$
其中$A\in Z_M$，对$1\le i\le k,a_i\in Z_m$，且$a_i=A~mod~m_i$,中国剩余定理说明下列两个断言成立

1. 式中的映射是$Z_M$到笛卡尔积$Z_{m1}\times Z_{m2}\times...\times Z_{mk}$的一一对应
2. $Z_M$中元素上的运算可等价于对应的k元组上的运算，即在笛卡尔积的每个分量上独立地执行运算



### 2.8 离散对数

离散对数是包含Diffie-Hellman密钥交换算法和数字签名算法(DSA)在内许多公钥算法的基础

#### 2.8.1 模n的整数幂

根据欧拉定理，任何互素的a和n，有
$$
a^{\phi(n)}\equiv 1(mod~n)
$$
欧拉定理更一般的表达形式
$$
a^m\equiv 1(mod~n)
$$
若a与n互素，则至少有一个整数m满足上式，即m=$\phi(n)$，我们称使得上式成立地最小正幂m为下列之一

1. a(mod n)的阶
2. a所属的模n的指数
3. a所产生的周期长

$\phi(n)$是一个数所属的模n的可能得最高指数，如果一个数的阶为$\phi(n)$，则称之为n的**本原根**

若a是n的本原根，则其幂
$$
a,a^2,...,a^{\phi({n})-1}
$$
是各不相同的，且均与n互素

并非所有整数都有本原根，只有形如2,4,$p^\alpha$和$2p^\alpha$的整数才有本原根，p是任何奇素数，α是正整数，证明过程不简单，在此省略



#### 2.8.2 模算术对数

对于某素数p的本原根a，a的1到p-1的各次幂恰可产生1到(p-1)的每个整数，且仅一次。对于任何整数b，根据模算术的定义,b满足
$$
b\equiv r(mod~p),0\le r\le(p-1)
$$
对任意整数b和素数p的本原根a，有唯一的幂i使得
$$
b\equiv a^i(mod~ p),0\le i\le (p-1)
$$
该指数i称为以a为底(模p)的b的离散对数，记为$dlog_{a,p}(b)$



#### 2.8.3 离散对数的计算

考虑方程
$$
y=g^x~modp
$$
给定g,x和p，可直接计算出y，在最坏情况下需要执行x次乘法，而且存在计算y的有效算法

但是给定y,g,p，计算x一般非常困难(即求离散对数)

对大素数而言，该算法是不可行的

# 第二部分 对称密码

## 第3章 传统加密技术

对称加密，也叫做传统加密或单钥加密,是使用最为广泛的加密类型

**一些术语**

- 明文：原始的消息
- 密文：加密后的消息
- 加密：从明文到密文的转换过程
- 解密：从密文到明文的变换过程
- 密码编码学：研究各种加密方案的领域
- 密码体制或密码：基于密码编码学的加密方案
- 密码分析学：不知道任何加密细节的条件下解密消息的技术
- 密码学：密码编码学和密码分析学统称为密码学

### 3.1 对称密码模型

对称加密方案有五个基本成分：

- **明文** 原始可理解的消息或数据，是算法的输入
- **加密算法** 加密算法对明文进行各种代替和变换
- **密钥** 密钥也是加密算法的输入。密钥独立于明文和算法。算法根据所用的特定密钥而产生不同的输出。算法所用的确切代替和变换也依靠密钥
- **密文** 作为算法的输出，看起来完全随机而杂乱的消息，依赖于明文和密钥。对于给定的消息，不同的密钥产生不同的密文，密文看上去是随机的数据流，并且其意义是不可理解的
- **解密算法** 本质上是加密算法的逆运算。输入密文和密钥，输出原始明文

传统密码的安全使用要满足以下两个要求：

1. 加密算法是足够强的

> 即使敌手拥有一定数量的密文和产生这些密文的明文，他也不能破译密文或发现密钥

2. 发送者和接收者必须在某种安全的形式下获得密钥并且必须保证密钥安全

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%9B%BE3.1%20%E4%BC%A0%E7%BB%9F%E5%AF%86%E7%A0%81%E7%9A%84%E7%AE%80%E5%8C%96%E6%A8%A1%E5%9E%8B.png)

假设基于已知密文和已知加密/解密算法而破译消息是不实际的

在这个条件下，我们不需要算法保密，仅需要密钥保密

对称密码的这些特点使其能够广泛地应用，算法不需要保密这一事实使得制造商可以开发出低成本的芯片以实现数据加密算法

**采用对称密码，首要的安全问题是密钥的保密性**



![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%9B%BE3.2%20%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6%E7%9A%84%E6%A8%A1%E5%9E%8B.png)

发送方产生明文消息X=[X1,X2,...,XM],X的M个元素是某个字母表中的字母

传统上，字母表由26个大写字母组成，而现在，最常用的是二进制字母表{0,1}

加密时，先产生一个形如K=[K1,K2,...,KJ]的密钥

如果密钥是由信息的发送方产生的，那么他要通过某种安全信道发送到接收方，另一种说法是由第三方生成密钥后再安全地分发给发送方和接收方



加密算法根据输入信息X和密钥K生成密文Y=[Y1,Y2,...,YN]，即
$$
Y=E(K,X)
$$
拥有密钥K的预定接收者，可以进行一下变化获得明文
$$
X=D(K,Y)
$$


#### 3.1.1 密码编码学

密码编码学系统具有以下三个独立的特征：

1. **转换明文为密文的运算类型**

所有的加密算法都基于两个原理——代替和置换

代替是将明文中的每个元素映射成另一个元素；置换是将明文中的元素重新排列

上述运算的基本要求是不允许有信息的丢失，即所有运算是可逆的

大多数密码体制，也成为乘积密码系统，都使用了多层代替和替换

2. **所用的密钥数**

如果发送方和接收方都是用相同的密钥，这种密码就称为对称密码，单密钥密码、秘密钥密码或传统密码

如果收发双方使用不同的密钥，这种密码就称为非对称密码，双钥或公钥密码

3. **处理明文的方法**

分组密码每次处理输入的一组元素，相应地输出一组元素

流密码则是连续地处理输入元素，每次输出一个元素



#### 3.1.2 密码分析学和穷举攻击

攻击密码系统地典型目标是恢复使用的密钥而非仅仅恢复出单个密文对应的明文

攻击传统的密码体制有两种通用的方法：

- **密码分析学**

密码分析学攻击依赖于算法的性质、明文的一般特征或某些明密文对。这种形式的攻击企图利用算法的特征来推导出特定的明文或使用的密钥

- **穷举攻击**

攻击者对一条密文尝试所有可能的密钥知道把它转化为可读的有意义的明文



**密码分析学攻击**

基于密码分析者知道信息的多少，可以概括出密码攻击的几种类型

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/3.1%20%E5%AF%B9%E5%8A%A0%E5%AF%86%E4%BF%A1%E6%81%AF%E7%9A%84%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B.png)

如果一个密码体制满足条件：无论有多少可使用的密文，都不足以唯一地确定密文所对应的明文，则称该密码体制是无条件安全的

除了一次一密，所有的加密算法都不是无条件安全的

加密算法的使用者应挑选尽量满足以下标准的算法：

- 破译密码的代价超出密文信息的价值
- 破译密码的时间超出密文信息的有效生命周期

加密体制满足上述两条标准种的任意一条，则它是计算上安全地



**穷举攻击**

尝试所有密钥直到有一个合法的密钥能够把密文还原成明文



### 3.2 代替技术

#### 3.2.1 Caesar密码

对于每个明文字母p，通过移位任意整数k，可以代替为密文字母C：
$$
C=E(k,p)=(p+k)~mod~(26)
$$

$$
p=D(k,C)=(C-k)~mod~(26)
$$



对Caesar密码的穷举攻击是很容易实现的，只要简单地测试所有25种可能得密钥，这取决于Caesar密码的三个特征：

1. 已知加密和解密算法
2. 需测试的密钥只有25个
3. 明文所用的语言是已知的，且其意义易于识别



#### 3.2.2 单表代替密码

通过允许任意代替，密钥空间将会急剧增大

一般地，具有n个元素的集合由n!个置换，这种方法被称为单表代替

通过把字母使用的相对频率统计出来，与英文字母的使用频率分布进行比较，根据统计规律，我们可以推测密文字母与明文字母的对应关系

统计双字母组合的频率也是一个很有效的工具

单表代替密码由于带有一些原始字母使用频率的统计学特征，很容易被攻破



#### 3.2.3 Playfair密码

Playfair密码是最著名的多字母代替密码，把明文中的双字母音节作为一个单元并将其转换为密文的"双字母音节"



**基于密钥词构造的字母矩阵**

Playfair密码的第一步是根据密钥词构造一个5x5的字母矩阵，构造方法如下：

先将密钥词(去掉重复字母)从左至右，从上到下填在矩阵格子中，再将剩余的字母按字母表的顺序从左至右，从上到下填在剩余的格子里,字母I/J当作一个字母



**加密过程**

明文按照如下规则，一次性加密两个字母

1. 如果该字母对的两个字母是相同的，那么在它们之间加一个填充字母
2. 落在矩阵同一行的明文字母对中的字母由其右边的字母来代替，每行最右边的一个字母就用该行最左边的字母代替
3. 落在矩阵同一列的明文字母对中的字母由其下面的字母来代替，每列中最下面的字母就用该列最上面的第一个字母来代替

4. 其他的魅族明文字母对中的字母按如下方式代替，该字母所在行为密文所在行，该字母所在列为密文所在列



相比于单表代替密码，Playfair密码要更优秀一些，26个字母由676个字母对，因此识别出单个字母对要困难得多，并且单个字母的相对频率比字母对的相对频率变化的幅度大，在统计规律上要好，利用频率分析字母对就更困难



Playfair密码仍然透露了大量的信息给密码分析者

#### 3.2.4 Hill密码

**Hill算法**

Hill加密算法将m个连续的明文字母替换成m个密文字母，该替换是由m个线性等式决定的，在等式里，每个字母被指定为一个数值(a=0,b=1,...,z=25)

当m=3时， 系统可以描述为
$$
c_1=(k_{11}p_1+k_{12}p_2+k_{13}P_3)~mod~26\\
c_2=(k_{21}p_1+k_{22}p_2+k_{23}P_3)~mod~26\\
c_3=(k_{31}p_1+k_{32}p_2+k_{33}P_3)~mod~26\\
$$
用行向量和矩阵表示如下
$$
(c_!,c_2,c_3)=(p_1,p_2,p_3) \begin{pmatrix}
k_{11} & k_{12} & k_{13} \\
k_{21} & k_{22} & k_{23} \\
k_{31} & k_{32} & k_{33}
\end{pmatrix} ~mod~26
$$
或
$$
\mathbf C=\mathbf P \mathbf K ~mod~26
$$


**Hill密码系统**

使用一般术语，Hill密码系统可表示如下:
$$
C=E(\mathbf K,\mathbf P)=\mathbf P \mathbf K~mod~26
$$

$$
\mathbf P=D(\mathbf K,\mathbf C)=\mathbf C \mathbf K^{-1}~mod~26=PKK^{-1}=P
$$



**Hill密码分析**

Hill密码完全隐蔽了单字母频率特性，Hill使用的矩阵越大，所隐藏的消息就越多

Hill密码足以抗惟密文攻击，但是它容易被已知明文攻击破解



#### 3.2.5 多表代替加密

对简单单标代替的改进方法是在明文消息中采用不同的单表代替，这种方式一般称之为多表代替密码，所有这些方法都有以下共同特征

1. 采用相关的单标代替规则集
2. 密钥决定给定变换的具体规则

##### **Vigenere 密码**

维吉尼亚密码是多表代替密码中最著名且最简单的密码，它的代替规则集由26个Caesar密码的代替表组成，其中每一个代替表是对明文字母表移位0~25次后得到的代替单表。每一个密码由一个密钥字母来表示，这个密钥字母用来代替明文字母a，故移位d次的Caesar密码由密钥值d来代表

假设明文序列为$P=p_0,p_1,...,p_{n-1}$，密钥由序列$K=k_0,k_1,...,k_{m-1}$构成，其中m<n，密码序列$C=C_0,C_1,...,C_{n-1}$计算如下
$$
C=C_0,C_1,...,C_{n-1}=E(K,P)=E[(k_0,k_1,...,k_{m-1},p_0,p_1,...,p_{n-1})]\\
=(p_0+k_0)~mod~26 (p_1+k_1)~mod~26,...,(p_{m-1}+k_{m-1})~mod~26,\\
(p_m+k_0)~mod~26,(p_{m+1}+k_1)~mod~26,...,(p_{2m-1}+k_{m-1})~mod~26,...
$$
加密过程的一般方程是
$$
C_i=(p_i+k_{i~mod~m})~mod~26
$$
解密方程
$$
p_i=(C_i-k_{i~mod~m})~mod~26
$$
**密码强度分析**

该密码使每个明文字母对应多个密文字母，且每个密文字母都使用唯一的密钥字母，屏蔽了字母出现的频率信息被屏蔽了，不过并非所有的明文结构信息都被隐蔽了



##### Vernam密码

该体制可简明表述为
$$
c_i=p_i \oplus k_i
$$
密文通过对明文和密钥的逐位异或形成，根据异或运算的特性，解密过程为
$$
p_i=c_i\oplus k_i
$$
事实上该体制使用的是周期很大的循环密钥

#### 3.2.6 一次一密

使用与消息一样长的且无重复的随机密钥来加密消息，且密钥只对一个消息进行加密，之后弃之不用

每一条新的消息都需要一个与其等长的新密钥

**安全性分析**

一次一密产生的随机输出与明文没有任何统计关系，密文不包含明文的任何消息，所以无法攻破

一次一密的安全性完全取决于密钥的随机性，如果构成密钥的字符流是真正随机的，那么构成密文的字符流也是真正随机的。分析者没有任何攻击密文的模式和规则可用

**两个基本难点**

1. 产生大规模随机密钥有实际困难
2. 密钥的分配和保护困难

因为上面这些困难，一次一密很少使用，主要用于安全性要求很高的低带宽信道

一次一密是唯一的具有完善保密的密码体制

### 3.3 置换技术

另一种加密方法，是对明文进行置换，称为置换密码



**栅栏密码**

按对角线顺序写出明文，而按行顺序读出作为密文

**一种更复杂的方案**

 将消息一行一行地写成矩形块，然后按列读出，但是把列的次序打乱，列的次序就是算法的密钥



单纯的置换密码因为有着与明文相同的字母频率特征而易被识别



多次置换密码相对来说更加安全，但复杂的置换是不容易重构的



### 3.4 轮转机

**基本原理**

轮转机包括一组相互独立的旋转圆筒，电脉冲可以通过它

每个圆筒有26个输入引脚和26个输出引脚

内部连线使每一个输入仅同唯一一个输出连接

**单筒系统**

只有一个圆筒的轮转机，每次按下一个输入键，圆筒就旋转一个位置，内部连线相应改变，经过26个明文字母后，圆筒回到初始位置，我们可以得到一个周期为26的多表代替面膜

**多筒系统**

每按依次输入键，第一个圆筒就旋转一个引脚的位置，第一个圆筒旋转完一圈后，第二个圆筒就转一个引脚的位置，以此类推

一个三筒系统，重复使用26x26x26=17576个不同的替换字母表

一个五筒轮转机相当于密钥长度为118811376的维吉尼亚密码

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E8%BD%AE%E8%BD%AC%E6%9C%BA.png)



### 3.5 隐写术

隐写术并不是加密，它是用来隐藏信息的存在

一些技术:

- 字符标记 选择一些印刷字母或打字机打出的文本，用铅笔在其上书写一遍，这些标记需要做得在一般场合下辨认不出，除非将纸张按某个角度对着亮光看
- 不可见墨水 有些物质用来书写后不留下可见痕迹，除非加热或加之以某种化学物质。
- 针刺 在某些字母上刺上小的针孔，这一般是分辨不出来的，除非对着光线。
- 打字机的色带矫正 用黑色的色带在行之间打印。用这种色带打印后的东西只在强光下可见。

**缺点**

它需要许多额外的付出来隐藏相对较少的信息。



**优点**

可以应用于如下的情况:通信双方宁愿内容丢失，也不愿他们进行秘密通信的事实被人发现。加密标识信息也是重要和秘密的，通过它可以找出想进行消息隐藏的发送方或接收方。



## 第4章 分组密码和数据加密标准

#### 4.1 传统分组密码结构

现在使用的大多数对称分组加密算法都是基于Feistel分组密码结构



#### 4.1.1 流密码与分组密码

**流密码**

流密码每次加密数据流的一位或一个字节

古典流密码的例子有密钥自动产生的Vigenere密码和Vernam密码，理想情况下，可以使用一次一密的Vernam密码，其中密钥流(ki)和明文位流(pi)一样长

密钥流必须提前以某种独立、安全的信道提供给双方，如果待传递的数据流量很大，就带来了一个不可逾越的障碍

在实际应用中，位流必须以算法程序的方式实现，从而双方都可以生产具有密码学意义的位流

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95%E6%AF%94%E7%89%B9%E6%B5%81%E5%8F%91%E7%94%9F%E5%99%A8%E7%9A%84%E6%B5%81%E5%AF%86%E7%A0%81.png)

位流发生器是一个由密钥控制的算法，它必须产生在密码学意义上是强壮的位流，两个用户只需要共享生成密钥，就可以各自产生密钥流



**分组密码**

将一个明文分组作为整体加密并且通常得到的是与明文等长的密文分组

分组大小通常为64位或128位

同流密码一样，两用户共享一个对称加密密钥

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81.png)

#### 4.1.2 Feistel密码结构的设计动机

**可逆变换**

分组密码作用在n位明文分组上，产生n位密文分组，共有$2^n$个不同的明文分组，且由于加密是可逆的，每一个明文分组将唯一地对应一个密文分组，这样的变换称为可逆变换，或非奇异变换



**理想分组密码**

允许生成最大数量的加密映射来映射明文分组

> **对于任意一个n bit的明文，都有一个唯一的n bit密文与之对应**



**理想分组密码应用的困难**

1. 对于小分组，密码系统等价于传统代替密码，容易被明文的统计分析方法攻击

2. 采用大规模分组的任意可逆代替密码(即理想分组密码)是不可行的，对于这样的密码，映射本身就是密钥

对于n位的代替分组密码，密钥规模是$n\times 2^n$，一个64位的分组密码，若分组有抗统计攻击的理想长度，其密钥大小约是$10^{21}$位



由于这些问题，Feistel指出我们所需的是对理想分组密码体制(分组长度n较大)的一种近似体制



#### 4.1.3 Feistel密码

Feistel建议使用乘积密码的概念来逼近理想分组密码

**乘积密码**

使用两个或两个以上的基本密码，所得结果的密码强度将强于所有单个密码的强度，这种方式的本质是开发一个分组密码，密钥长度k位，分组长度n位，采用$2^k$个变换，而不是理想分组密码的$2^n!$个可用变换



Feistel建议使用这样的密码：该种密码交替地使用代替和置换

- 代替：每个明文元素或元素组被唯一地替换为相应的密文元素或元素组
- 置换：明文元素的序列被替换为该序列的一个置换

> 事实上，这就是Claude Shannon提出的交替使用混淆和扩散的乘积密码的实际应用



**混淆与扩散**

扩散：明文的统计特征消散在密文中，这可以通过让每个明文数字尽可能多地影响多个密文数字获得

一个扩散的例子：使用下面的方法加密一段消息
$$
y_n=(\sum_{i=1}^k m_{n+i})~mod~26
$$
或者在二进制分组密码中，对明文进行置换后再用某个函数作用，重复多次就可以获得比较好的扩散效果



混淆：尽可能使密文和加密密钥间的统计关系



**Feistel密码结构**

加密算法的输入是2w位的明文分组和密钥K。明文分组被分为等长的两部分:$LE_0和RE_0$

这两半数据经过n轮迭代后组合成密文组合

第i轮迭代的输入$LE_{i-1}和RE_{i-1}$来自于上轮迭代的输出

而输入的子密钥$K_i$是由整个密钥K推导出的

每轮迭代都有相同的结构，代替作用在数据的左半部分。通常用轮函数F作用于数据的右半部分后，与左半部分数据进行异或来完成

每轮迭代的轮函数是相同的，但是输入的子密钥$K_i$不同

代替之后，交换数据的左右两半完成置换

这种结构是Shannon提出的代替置换网络的一种特别形式

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/Feistel%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86.png)

Feistel结构的具体实现依赖于以下参数和特征：

- **分组长度** 分组长度越长意味着安全性越高，但是会降低加、解密速度，这种安全性的增加来自更好的扩散性，传统上，分组长度为64位比较合理，高级加密标准使用的是128位的分组长度

- **密钥长度** 密钥较长意味着安全性较高，但会降低加解密速度，这种安全性的增加来自于更好的抗穷尽攻击能力和更好的混淆性， 一般认为密钥长度位64位还不够，通常使用128位密钥
- **迭代轮数** Feistel密码的本质在于单轮不能提供足够的安全性而多轮加密可取得很高的安全性
- **子密钥生成算法** 子密钥产生越复杂，密码分析就越困难
- **轮函数** 轮函数越复杂，抗攻击能力就越强

其他两方面的考虑：

- **快速软件加解密** 加密算法被嵌入应用程序中，避免硬件实现的麻烦
- **简化分析难度** 有些时候，将算法设计的容易分析也有它的好处，比如分析其脆弱性，从而开发出更强的算法



**Feistel解密算法**

如上图，将密文作为算法的输入，逆序使用子密钥$K_i$



### 4.2 数据加密标准

DES 数据加密标准在2001年高级加密标准(AES)提出前，一直是使用最广泛的加密方案

DES使用64位分组长度和56位密钥长度，将64位输入经过一系列变换得到64位的输出。解密则使用了相同的步骤和密钥

该算法本身指的是数据加密算法(DEA)



#### 4.2.1 DES加密

![](image/%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DES%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0.png)

对于任意加密方案，总共由两个输入：明文和密钥

DES的明文长度为64位，密钥长度为56位



**明文处理**

明文处理经过三个阶段:

1. 64位明文经过初始置换IP而被重新排列
2. 经过16轮相同函数的作用，每轮作用都有置换和代替。最后一轮迭代的输出有64位，它是输入明文和密钥的函数。其左半部分和右半部分互换产生预输出
3. 预输出再被与初始置换IP互逆的置换$IP^{-1}$作用产生64位的密文

**子密钥生成**

1. 密钥经过一个置换
2. 密钥经过循环左移和一个置换，分别得到各轮的子密钥$K_i$用于各轮的迭代



#### 4.2.2 DES解密

Feistel密码的解密算法和加密算法是相同的，只是子密钥的使用次序相反，此外，初始置换和最终置换是相反的
